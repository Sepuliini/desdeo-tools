import abc
from abc import abstractmethod
from os import path
from typing import List, Union

import numpy as np


class GLIDEError(Exception):
    """Raised when an error related to the ASF classes is encountered.

    """


class GLIDEBase:
    """
    Implements the non-differentiable variant of GLIDE-II as proposed in
    Ruiz, Francisco, Mariano Luque, and Kaisa Miettinen.
    "Improving the computational efficiency in a global formulation (GLIDE)
    for interactive multiobjective optimization."
    Annals of Operations Research 197.1 (2012): 47-70.

    Note: 
        Additional contraints produced by the GLIDE-II formulation are implemented
        such that if the returned values are negative, the corresponding constraint is
        violated. The returned value may be positive. In such cases, the returned value
        is a measure of how close or far the corresponding feasible solution is from
        violating the constraint.

    Args:
        utopian (np.ndarray, optional): The utopian point. Defaults to None.
        nadir (np.ndarray, optional): The nadir point. Defaults to None.
        rho (float, optional): The augmentation term for the scalarization function.
            Defaults to 1e-6.
    """

    def __init__(
        self, utopian: np.ndarray = None, nadir: np.ndarray = None, rho: float = 1e-6
    ):

        self.num_additional_constraints = 0
        self.utopian = utopian
        self.nadir = nadir
        self.rho = rho

    def __call__(self, objective_vector: np.ndarray, preference: dict) -> np.ndarray:
        """Returns the Objecti

        Args:
            objective_vector (np.ndarray): [description]
            preference (dict): [description]

        Returns:
            np.ndarray: The scalarized value obtained by using GLIDE-II over
                objective_vector.
        """
        self.preference = preference
        self.objective_vector = objective_vector

        f_minus_q = np.atleast_2d(objective_vector - self.q)
        mu = np.atleast_2d(self.mu)
        I_alpha = self.I_alpha

        max_term = np.max(mu[:, I_alpha] * f_minus_q[:, I_alpha], axis=1)
        sum_term = self.rho * np.sum(self.w * f_minus_q, axis=1)
        return max_term + sum_term

    def evaluate_constraints(
        self, objective_vector: np.ndarray, preference: dict
    ) -> Union[None, np.ndarray]:
        """Evaluate the additional contraints generated by the GLIDE-II formulation.

        Note: 
            Additional contraints produced by the GLIDE-II formulation are implemented
            such that if the returned values are negative, the corresponding constraint is
            violated. The returned value may be positive. In such cases, the returned value
            is a measure of how close or far the corresponding feasible solution is from
            violating the constraint.

        Args:
            objective_vector (np.ndarray): [description]
            preference (dict): [description]

        Returns:
            Union[None, np.ndarray]: [description]
        """
        if self.num_additional_constraints == 0:
            return None

        self.preference = preference
        self.objective_vector = objective_vector

        constraints = (
            self.epsilon[:, self.I_epsilon]
            + self.s_epsilon * self.delta_epsilon[self.I_epsilon]
            - objective_vector[:, self.I_epsilon]
        )

        return constraints

    @property
    @abstractmethod
    def I_alpha(self):
        pass

    @property
    @abstractmethod
    def I_epsilon(self):
        pass

    @property
    @abstractmethod
    def mu(self):
        pass

    @property
    @abstractmethod
    def q(self):
        pass

    @property
    @abstractmethod
    def w(self):
        pass

    @property
    @abstractmethod
    def epsilon(self):
        pass

    @property
    @abstractmethod
    def s_epsilon(self):
        pass

    @property
    @abstractmethod
    def delta_epsilon(self):
        pass


class reference_point_method_GLIDE(GLIDEBase):
    def __init__(
        self, utopian: np.ndarray = None, nadir: np.ndarray = None, rho: float = 1e-6
    ):
        super().__init__(utopian=utopian, nadir=nadir, rho=rho)
        self.num_additional_constraints = 0
        self.__I_alpha = np.full_like(utopian, dtype=bool, fill_value=True).flatten()
        self.__I_epsilon = np.full_like(utopian, dtype=bool, fill_value=False).flatten()
        self.__w = 1
        self.__mu = 1 / nadir - utopian

    @property
    def I_epsilon(self):
        return self.__I_epsilon

    @property
    def I_alpha(self):
        return self.__I_alpha

    @property
    def mu(self):
        return self.__mu

    @property
    def w(self):
        return self.__w

    @property
    def q(self):
        return self.preference["reference_point"]

    @property
    def epsilon(self):
        msg = "This part of the code should not be reached. Contact maintaner."
        raise GLIDEError(msg)

    @property
    def s_epsilon(self):
        msg = "This part of the code should not be reached. Contact maintaner."
        raise GLIDEError(msg)

    @property
    def delta_epsilon(self):
        msg = "This part of the code should not be reached. Contact maintaner."
        raise GLIDEError(msg)

